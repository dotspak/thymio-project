<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="0" name="STOPPED"/>
<constant value="1" name="LEFT"/>
<constant value="2" name="RIGHT"/>
<constant value="3" name="HARD_TURN_RIGHT"/>
<constant value="4" name="HARD_TURN_LEFT"/>
<constant value="5" name="AVOID_RIGHT"/>
<constant value="6" name="AVOID_LEFT"/>
<constant value="7" name="AVOID_STRAIGHT"/>
<constant value="500" name="TARGET"/>
<constant value="300" name="HARD_TURN_SPEED"/>
<constant value="300" name="HARD_TURN_THRESHOLD"/>
<constant value="750" name="HARD_TURN_THRESHOLD2"/>
<constant value="600" name="TURN_TIMER"/>
<constant value="600" name="AVOID_THRESHOLD"/>
<constant value="400" name="STRAIGHT_TIME"/>
<constant value="900" name="HARD_TURN_LIMIT"/>
<constant value="500" name="AVOID_SPEED"/>
<constant value="1200" name="BLOCK_DETECT"/>
<constant value="5000" name="STOP_LINE_TIME"/>
<constant value="200" name="DIFF"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II"># -----------------------------------
# Midterm Project - Line Follower with Hard Turn Recovery
# Group 6:
# Cole Smith-Evans  B00903345
# Cynthia Hayes      B01051658
# Alwin Tenkorang    B01014380
# Nathan Ikeme       B01059341
# -----------------------------------

var state = STOPPED
var diff
var min
var max
var mean
var canDetectLine = 1
var canDetectBlock = 1
var canHardTurn = 1
var lastSide = LEFT

motor.left.target = 0
motor.right.target = 0

# Start moving left (button forward)
onevent button.forward
    callsub EnterLeft


# Stop robot (button backward)
onevent button.backward
    callsub EnterStop


# Proximity event - handle sensors and line following
onevent prox
	call math.stat( prox.horizontal[0:3], min, max, mean ) # compute stats on data
    if state != STOPPED then
    	# right avoid to left
				if state == AVOID_RIGHT and prox.horizontal[4] > AVOID_THRESHOLD then
				  	callsub EnterAvoidLeft
				  	return
				end
				
				# left avoid to straight
				if state == AVOID_LEFT and prox.horizontal[4] &lt; AVOID_THRESHOLD then
			      callsub EnterAvoidStraight
			      return
				end
				
    		if canDetectLine == 1 then
    			diff = prox.ground.delta[0] - prox.ground.delta[1]
    			
    			if state > 4 then
    				if diff &lt; -DIFF then 
    					canDetectBlock = 0
    					callsub EnterLeft
    					timer.period[1] = 1000
    				elseif diff > DIFF then
    					canDetectBlock = 0
	    				callsub EnterRight
	    				timer.period[1] = 1000	 
    				end			
	    		end

	        	#Stable normal turn
		     	if diff &lt; -DIFF then callsub EnterLeft
		     	elseif diff > DIFF then callsub EnterRight end
	        
	        	#Lost line recovery
	        	if prox.ground.delta[0] > HARD_TURN_THRESHOLD2 and prox.ground.delta[1] > HARD_TURN_THRESHOLD2 and state != HARD_TURN_LEFT and state != HARD_TURN_RIGHT then
	            if canHardTurn == 1 then
	            	callsub EnterHardLeft
	              	#if lastSide == LEFT then callsub EnterHardRight
	               #else callsub EnterHardLeft end
	            end
	        	end 
	        	
	        	 # enter avoid
			   if max > BLOCK_DETECT and state &lt; 5 and canDetectBlock == 1 then
			   	canHardTurn = 0
			     	canDetectLine = 0
			      callsub EnterAvoidLeft
			      timer.period[0] = STOP_LINE_TIME
			  	end
	    	else
	    		
	    	end
     end


# Timer event to allow new hard turn after a delay
onevent timer0
    	timer.period[0] = 0
    	
    	if state >= 5 then
    		canDetectLine = 1
    		return
    	end
    	
	if state != HARD_TURN_LEFT and state != HARD_TURN_RIGHT then
    		canHardTurn = 1	
	else
		if state == HARD_TURN_LEFT then
			callsub EnterHardRight
		else
			callsub EnterHardLeft
		end
	end
	
    
# Timer1 handles avoiding the blocks
onevent timer1
	timer.period[1] = 0
	
	if state &lt; 5 then canDetectBlock = 1
	else callsub EnterAvoidRight
	end
	

# -----------------------------------------
# functions
# -----------------------------------------
sub EnterLeft
    state = LEFT
    lastSide=LEFT
    canHardTurn = 0
    timer.period[0] = TURN_TIMER
    motor.left.target = TARGET / 2
    motor.right.target = TARGET
    call leds.circle(0,0,0,0,0,0,255,0)


sub EnterRight
    state = RIGHT
    lastSide=RIGHT
    canHardTurn = 0
    timer.period[0] = TURN_TIMER
    motor.left.target = TARGET
    motor.right.target = TARGET / 2
    call leds.circle(0,0,255,0,0,0,0,0)
    
    
sub EnterHardLeft
    state = HARD_TURN_LEFT
    lastSide = LEFT
    motor.left.target = -TARGET
    motor.right.target = TARGET
    timer.period[0] = HARD_TURN_LIMIT
    call leds.circle(0,0,0,0,0,255,255,255)


sub EnterHardRight
    state = HARD_TURN_RIGHT
    lastSide = RIGHT
    motor.left.target = TARGET
    motor.right.target = -TARGET
    #timer.period[0] = HARD_TURN_LIMIT
    call leds.circle(0,255,255,255,0,0,0,0)


sub EnterStop
    state = STOPPED
    motor.left.target = 0
    motor.right.target = 0
    
    canDetectBlock = 1
    canDetectLine = 1
    canHardTurn = 1
	
	
sub EnterAvoidRight
	state = AVOID_RIGHT
	motor.left.target = AVOID_SPEED
	motor.right.target = -AVOID_SPEED
	call leds.circle(0,0,255,255,0,0,0,0)

	
sub EnterAvoidStraight
	state = AVOID_STRAIGHT
	motor.left.target = AVOID_SPEED - 150
	motor.right.target = AVOID_SPEED - 100
	timer.period[1] = STRAIGHT_TIME
	call leds.circle(0,0,255,255,0,0,255,255)
	

sub EnterAvoidLeft
	state = AVOID_LEFT
	motor.left.target = -AVOID_SPEED
	motor.right.target = AVOID_SPEED
	call leds.circle(0,0,0,0,0,0,255,255)
	
	</node>


</network>
